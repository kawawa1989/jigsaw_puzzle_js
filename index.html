<!DOCTYPE html>
<html lang="ja">

<head>
	<meta charset="UTF-8">
	<title>Start with pixi.js</title>
</head>

<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.4.3/pixi.min.js"></script>
	<script type="text/javascript">
		var type = "WebGL";
		if (!PIXI.utils.isWebGLSupported()) {
			type = "canvas"
		}
		PIXI.utils.sayHello(type);

		// 新しいレンダラー作る
		// 720 * 1280
		var renderer = PIXI.autoDetectRenderer(360, 640, { antialias: true, backgroundColor: 0xDDDDDD });
		renderer.view.style.width = '720px';
		renderer.view.style.height = '1280px';

		// それをHTMLファイルに入れる
		document.body.appendChild(renderer.view);

		// stageという名前の容器（オプジェクト）を作る
		var scene = new PIXI.Container();




		// テクスチャ読み込み
		PIXI.loader
			.add("images/picture01.png")
			.load(setup);
		var draggingObject = null;
		var pictureTexture = null;
		var pieceFrame = [];
		var pieces = [];
		var pieceContainer = null;
		var frameContainer = null;
		var pieceXNum = 3;
		var pieceYNum = 3;

		function setup() {
			pictureTexture = PIXI.Texture.fromImage("images/picture01.png");
			var pieceDataList = [];
			for (var y = 0; y < pieceYNum; ++y) {
				var row = [];
				for (var x = 0; x < pieceXNum; ++x) {
					row.push({ top: 0, right: 0, bottom: 0, left: 0 });
				}
				pieceDataList.push(row);
			}
			pieceContainer = new PIXI.Container();
			frameContainer = new PIXI.Container();
			scene.addChild(frameContainer);
			scene.addChild(pieceContainer);

			for (var y = 0; y < pieceDataList.length; ++y) {
				var row = pieceDataList[y];
				for (var x = 0; x < row.length; ++x) {
					var piece = row[x];
					piece.right = Math.pow(-1, Math.floor(Math.random() * 2));
					piece.bottom = Math.pow(-1, Math.floor(Math.random() * 2));
					if (x + 1 < row.length) {
						row[x + 1].left = -piece.right;
					}
					if (y + 1 < pieceDataList.length) {
						pieceDataList[y + 1][x].top = -piece.bottom;
					}


					if (x == row.length - 1) {
						piece.right = 0;
					}
					if (x == 0) {
						piece.left = 0;
					}
					if (y == 0) {
						piece.top = 0;
					}
					if (y == pieceDataList.length - 1) {
						piece.bottom = 0;
					}

					var posX = Math.random() * 250;
					var posY = 300 + (Math.random() * 200);
					var c = createPieceContainer(posX, posY, x, y, piece.top, piece.right, piece.bottom, piece.left);
					pieces.push(c);
					scene.addChild(c);
					pieceContainer.addChild(c);
				}
			}

			for (var y = 0; y < pieceDataList.length; ++y) {
				var row = pieceDataList[y];
				for (var x = 0; x < row.length; ++x) {
					var piece = row[x];
					var obj = createPieceMask(1, piece.top, piece.right, piece.bottom, piece.left, 100, false);
					obj.position.x = x * 100;
					obj.position.y = y * 100;
					frameContainer.addChild(obj);
					pieceFrame.push(obj);
				}
			}
			console.log("setup!!");
		}


		function createPieceContainer(x, y, column, row, top, right, bottom, left) {
			var contentWidth = pictureTexture.width / pieceXNum;
			var container = new PIXI.Container();
			var graphics = createPieceMask(1, top, right, bottom, left, contentWidth, true);
			var edge = createPieceMask(1, top, right, bottom, left, contentWidth, false);
			// スプライト生成
			var sprite = new PIXI.Sprite(pictureTexture);
			container.interactive = true;
			container.width = contentWidth;
			container.addChild(sprite);
			container.addChild(graphics);
			container.addChild(edge);

			sprite.mask = graphics;
			container.position.x = x;
			container.position.y = y;
			sprite.width = pictureTexture.width;
			sprite.height = pictureTexture.height;
			sprite.position.x = -1 * column * contentWidth;
			sprite.position.y = -1 * row * contentWidth;


			// ドラッグを開始
			container.on('mousedown', onDragStart)
			container.on('touchstart', onDragStart)
			// ドロップ（ドラッグを終了）
			container.on('mouseup', onDragEnd)
			container.on('mouseupoutside', onDragEnd)
			container.on('touchend', onDragEnd)
			container.on('touchendoutside', onDragEnd)
			// ドラッグ中
			container.on('mousemove', onDragMove)
			container.on('touchmove', onDragMove)
			container.pieceNumber = column + (row * 3);
			container.set = false;
			return container;
		}


		function onDragStart(event) {
			if (draggingObject) {
				return;
			}
			if (this.set) {
				return;
			}
			pieceContainer.removeChild(this);
			pieceContainer.addChild(this);

			console.log("pieceNumber:" + this.pieceNumber);
			draggingObject = this;
			var pos = event.data.getLocalPosition(this.parent);
			this.distance = { x: 0, y: 0 };
			this.distance.x = this.position.x - pos.x;
			this.distance.y = this.position.y - pos.y;

			// store a reference to the data
			// the reason for this is because of multitouch
			// we want to track the movement of this particular touch
			this.data = event.data;
			this.alpha = 0.5;
			this.dragging = true;
		}

		function onDragEnd() {
			this.alpha = 1;
			this.dragging = false;
			// set the interaction data to null
			this.data = null;
			draggingObject = null;
			hitCheck(this);
			checkClear();
		}

		function checkClear() {
			for (var i = 0; i < pieces.length; ++i) {
				if (!pieces[i].set) {
					return false;
				}
			}
			window.alert("Game Clear!!");
		}

		function hitCheck(content) {
			var isHit = function (a, b) {
				// 当たり判定
				if (Math.abs(a.x - b.x) < (a.width / 2) + (b.width / 2) && Math.abs(a.y - b.y) < (a.height / 2) + (b.height / 2)) {
					return true;
				}
				return false;
			};

			var aw = content.width / 8;
			var ah = content.height / 8;
			var arect = {
				x: content.position.x + (content.width / 2),
				y: content.position.y + (content.height / 2),
				width: aw,
				height: ah
			};
			var brect = {
				x: 0,
				y: 0,
				width: 0,
				height: 0,
			};

			for (var i = 0; i < pieceFrame.length; ++i) {
				var bw = pieceFrame[i].width / 8;
				var bh = pieceFrame[i].height / 8;

				brect.x = pieceFrame[i].position.x + (pieceFrame[i].width / 2);
				brect.y = pieceFrame[i].position.y + (pieceFrame[i].height / 2);
				brect.width = bw;
				brect.height = bh;
				if (isHit(arect, brect)) {
					if (content.pieceNumber == i) {
						content.set = true;
						content.position.x = pieceFrame[i].position.x;
						content.position.y = pieceFrame[i].position.y;
					}
				}
			}
		}

		function onDragMove() {
			if (this.dragging) {
				var newPosition = this.data.getLocalPosition(this.parent);
				this.position.x = this.distance.x + newPosition.x;
				this.position.y = this.distance.y + newPosition.y;
			}
		}




		function createPieceMask(tileRatio, topTab, rightTab, bottomTab, leftTab, tileWidth, fill) {
			var mask = new PIXI.Graphics();
			if (fill) {
				mask.beginFill(0x494949);
			}
			else {
				mask.lineStyle(2, 0x0000FF, 1);
			}
			var curvyCoords = [
				0, 0, 35, 15, 37, 5,
				37, 5, 40, 0, 38, -5,
				38, -5, 20, -20, 50, -20,
				50, -20, 80, -20, 62, -5,
				62, -5, 60, 0, 63, 5,
				63, 5, 65, 15, 100, 0
			];
			var topLeftEdge = { x: 0, y: 0 };
			mask.moveTo(topLeftEdge.x, topLeftEdge.y);

			//Top
			for (var i = 0; i < curvyCoords.length / 6; i++) {
				var p1 = { x: topLeftEdge.x + (curvyCoords[i * 6 + 0] * tileRatio), y: topLeftEdge.y + (topTab * curvyCoords[i * 6 + 1] * tileRatio) };
				var p2 = { x: topLeftEdge.x + (curvyCoords[i * 6 + 2] * tileRatio), y: topLeftEdge.y + (topTab * curvyCoords[i * 6 + 3] * tileRatio) };
				var p3 = { x: topLeftEdge.x + (curvyCoords[i * 6 + 4] * tileRatio), y: topLeftEdge.y + (topTab * curvyCoords[i * 6 + 5] * tileRatio) };
				mask.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
			}
			//Right
			var topRightEdge = { x: topLeftEdge.x + tileWidth, y: topLeftEdge.y + 0 };
			for (var i = 0; i < curvyCoords.length / 6; i++) {
				var p1 = { x: topRightEdge.x + (-rightTab * curvyCoords[i * 6 + 1] * tileRatio), y: topRightEdge.y + (curvyCoords[i * 6 + 0] * tileRatio) };
				var p2 = { x: topRightEdge.x + (-rightTab * curvyCoords[i * 6 + 3] * tileRatio), y: topRightEdge.y + (curvyCoords[i * 6 + 2] * tileRatio) };
				var p3 = { x: topRightEdge.x + (-rightTab * curvyCoords[i * 6 + 5] * tileRatio), y: topRightEdge.y + (curvyCoords[i * 6 + 4] * tileRatio) };
				mask.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
			}
			//Bottom
			var bottomRightEdge = { x: topRightEdge.x + 0, y: topRightEdge.y + tileWidth };
			for (var i = 0; i < curvyCoords.length / 6; i++) {
				var p1 = { x: bottomRightEdge.x - (curvyCoords[i * 6 + 0] * tileRatio), y: bottomRightEdge.y - (bottomTab * curvyCoords[i * 6 + 1] * tileRatio) };
				var p2 = { x: bottomRightEdge.x - (curvyCoords[i * 6 + 2] * tileRatio), y: bottomRightEdge.y - (bottomTab * curvyCoords[i * 6 + 3] * tileRatio) };
				var p3 = { x: bottomRightEdge.x - (curvyCoords[i * 6 + 4] * tileRatio), y: bottomRightEdge.y - (bottomTab * curvyCoords[i * 6 + 5] * tileRatio) };
				mask.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
			}
			//Left
			var bottomLeftEdge = { x: bottomRightEdge.x - tileWidth, y: bottomRightEdge.y - 0 };
			for (var i = 0; i < curvyCoords.length / 6; i++) {
				var p1 = { x: bottomLeftEdge.x - (-leftTab * curvyCoords[i * 6 + 1] * tileRatio), y: bottomLeftEdge.y - (curvyCoords[i * 6 + 0] * tileRatio) };
				var p2 = { x: bottomLeftEdge.x - (-leftTab * curvyCoords[i * 6 + 3] * tileRatio), y: bottomLeftEdge.y - (curvyCoords[i * 6 + 2] * tileRatio) };
				var p3 = { x: bottomLeftEdge.x - (-leftTab * curvyCoords[i * 6 + 5] * tileRatio), y: bottomLeftEdge.y - (curvyCoords[i * 6 + 4] * tileRatio) };
				mask.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
			}
			if (fill) {
				mask.endFill();
			}
			return mask;
		}

		/*
		graphics.bezierCurveTo(75,37,70,25,50,25);
		graphics.bezierCurveTo(20,25,20,62.5,20,62.5);
		graphics.bezierCurveTo(20,80,40,102,75,120);
		graphics.bezierCurveTo(110,102,130,80,130,62.5);
		graphics.bezierCurveTo(130,62.5,130,25,100,25);
		graphics.bezierCurveTo(85,25,75,37,75,40);
		*/
		function update() {
		}

		/**
		 * animation関数を定義
		 */
		var animation = function () {
			// 再帰的に次のアニメーションフレームで animation関数を呼び出す
			requestAnimationFrame(animation);
			update();

			// 描画
			renderer.render(scene);
		};
		animation();

	</script>
</body>

</html>